#!/usr/bin/env python
__author__ = "Gao Wang"
__copyright__ = "Copyright 2016, Stephens lab"
__email__ = "gaow@uchicago.edu"
__license__ = "MIT"
import os
import json

def get_home_doc(db):
    return '''
This page displays contents of database `{0}.db` generated by [this DSC]({0}.html). There are two types of tables in the database:

* **pipeline** tables: *add description*
* **module** tables: *add description*
'''.format(os.path.basename(db)[:-3])

def write_notebook(text, output, execute = True):
    import nbformat
    nb = nbformat.reads(text, as_version = 4)
    if execute:
        from nbconvert.preprocessors import ExecutePreprocessor
        ep = ExecutePreprocessor(timeout=600, kernel_name='SoS')
        ep.preprocess(nb, {})
    with open(os.path.expanduser(output), 'wt') as f:
        nbformat.write(nb, f)

def get_database_notebook(db, output, title = "Database Summary", description = None):
    import pickle
    jc = JupyterComposer()
    jc.add("# {}\n{}".format(title,
                             '\n\n'.join(description) if description is not None
                             else get_home_doc(db)))
    jc.add('''
import pickle
data = pickle.load(open("{}", 'rb'))
    '''.format(os.path.expanduser(db)), cell = "code", out = False)
    data = pickle.load(open(os.path.expanduser(db), 'rb'))
    jc.add("## Pipelines")
    for key in data:
        if key.startswith('pipeline_') and not key.endswith(".captain"):
            captain = data[key + '.captain']
            jc.add("### pipeline{} `{}`\nExecuted pipelines:\n{}".\
                   format('s' if len(captain) > 1 else '', key[9:],
                          '\n'.join(['* ' + ' + '.join(["`{}`".format(x) for x in seq]) for seq in captain])))
            jc.add("%preview -n data['{0}']".format(key), cell = "code")
    jc.add("## Modules")
    for key in data:
        if not key.startswith("pipeline_") and not key.startswith('.'):
            jc.add("### module `{}`".format(key))
            jc.add("%preview -n data['{}']".format(key), cell = "code")
    with open(os.path.basename(db)[:-3] + '.html', 'w') as f:
        f.write(data['.html'])
    write_notebook(jc.dump(), output)

def get_query_notebook(db, queries, output, title, description = None, language = None, addon = None):
    jc = JupyterComposer()
    jc.add("# {}\n{}".format(title,
                             '\n\n'.join(description) if description is not None
                             else ''))
    jc.add('''
import warnings
warnings.filterwarnings("ignore")
from dsc.utils import load_rds
import pandas as pd
info = [pd.DataFrame.from_dict(x) for x in load_rds("{}").values()]
    '''.format(os.path.expanduser(db)), cell = "code", out = False)
    for i, q in enumerate(queries):
        jc.add("## Pipeline {}".format(i + 1))
        jc.add("```sql\n{}\n```".format(q), out = False)
        jc.add("%preview -n info[{}]".format(i), cell = "code")
    if language is not None:
        if language == 'R':
            jc.add("%use R\ninfo <- readRDS('{}')".format(db), cell = "code", out = False)
        else:
            jc.add("%use {}\n%get info".format(language), cell = "code", out = False)
        if addon is not None:
            files = [os.path.expanduser(x) for x in addon]
            for item in files:
                if not os.path.isfile(item):
                    raise OSError("Cannot find file ``{}``!".format(item))
                jc.add(open(item).read(), cell = "code", out = False, kernel = language)
    write_notebook(jc.dump(), output)

class JupyterComposer:
    def __init__(self):
        self.text = ['{\n "cells": [']
        self.has_end = False

    def add(self, content, cell = "markdown", kernel = "SoS", out = True):
        content = [x + '\n' for x in content.strip().split("\n")]
        content[-1] = content[-1].rstrip('\n')
        self.text.append('  {\n   "cell_type": "%s",%s\n   %s\n   %s"source": %s' \
                         % (cell, '\n   "execution_count": null,' if cell == "code" else '',
                            self.get_metadata(cell, kernel, out),
                            '"outputs": [],\n   'if cell == 'code' else '',
                            json.dumps(content)))
        self.text.append("  },")

    def dump(self):
        if not self.has_end:
            self.text.append(self.get_footer())
            self.has_end = True
        return '\n'.join(self.text)

    def get_footer(self):
        self.text[-1] = self.text[-1].rstrip().rstrip(',')
        return ''' ],
 "metadata": {
  "anaconda-cloud": {},
  "celltoolbar": "Tags",
  "kernelspec": {
   "display_name": "SoS",
   "language": "sos",
   "name": "sos"
  },
  "language_info": {
   "codemirror_mode": "sos",
   "file_extension": ".sos",
   "mimetype": "text/x-sos",
   "name": "sos",
   "nbconvert_exporter": "sos.jupyter.converter.SoS_Exporter",
   "pygments_lexer": "sos"
  },
  "sos": {
   "kernels": [],
   "panel": {
    "displayed": true,
    "height": 0,
    "style": "side"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}'''

    @staticmethod
    def get_metadata(cell, kernel, out):
        def get_tag():
            if cell == 'code' and out:
                return "report_output"
            elif cell == 'markdown' and not out:
                return "hide_output"
        #
        out = '"metadata": {\n    "collapsed": false,\n    "kernel": "%s",\n    "scrolled": true,\n    "tags": ["%s"]\n   },' % (kernel, get_tag())
        return out

if __name__ == '__main__':
    # jc = JupyterComposer()
    # jc.add("# Title")
    # jc.add("print(666)", cell = 'code', kernel = 'SoS')
    # jc.add("print(999)", cell = 'code', kernel = 'SoS', out = True)
    # print(jc.dump())
    import sys
    get_database_notebook(sys.argv[1], sys.argv[2])
