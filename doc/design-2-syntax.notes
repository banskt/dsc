###
#! DSC2 syntax
###
###
# DSC file structure
###
# DSC2 is configured by a text file in [YAML format|@http://yaml.org@] (referred to as "DSC file" hereafter) with multiple sections. Each section in the DSC file, except for the last one (section name ""DSC""), is called a "DSC block" (referred to as "block" hereafter). All blocks share the same syntax.
# The ""DSC"" section consists of [3 sequences|@Design-and-Features#Overview@], plus a ""runtime"" environment which specifies various other parameters in a DSC run (for example required R libraries, path to executable folders, DSC global variables and output database names).
# Lines in a DSC file are called "DSC entries", separated by comma (``,''), to allow for a range of parameters be assigned to multiple computational routine so that DSC can be performed under various scenarios for many methods.
# You may glance over these DSC files to have an idea of DSC2 syntax. It is also recommended that you read the [DSC design|@Design-and-Features@] before diving into the details throughout the rest of the document.
#{list
# [Location parameter estimate I|@https://github.com/stephenslab/dsc2/tree/master/vignettes/one_sample_location/settings.yaml@] and [II|@https://github.com/stephenslab/dsc2/tree/master/vignettes/two_sample_mean/settings.yaml@]
# [Adaptive Shrinkage|@https://github.com/stephenslab/dsc2/tree/master/vignettes/ash/settings.yaml@]
# [Adaptive Shrinkage on variance|@https://github.com/stephenslab/dsc2/tree/master/vignettes/vash/settings.yaml@]
# [Outlier detection from population data|@https://github.com/stephenslab/dsc2/tree/master/vignettes/outlier_r/settings.yaml@]
#}
###
# DSC Block Parameters
###
#! Primary parameters
#!! level [required]
# FIXME
#!! exe [required]
# @@exe@@ specifies the name of executable computer routines as well as their command line arguments if applicable, for example a DSC entry reads:
#{out yaml
exe: datamaker.R, ms $nsam $nreps -t $theta -seed $seed
#}
# where data is generated by two programs, @@datamaker.R@@ and @@ms@@, with command line arguments @@nsam@@, @@nreps@@ and @@theta@@ & @@seed@@ for @@ms@@ (parameters for @@exe@@ will be discussed later). Although @@exe@@ takes arbitrary command line programs, if the input is R script, for example @@datamaker.R@@, then there is no need to explicitly specify input parameters such as @@nsam@@ and @@nreps@@, as long as the parameter names match the variable names coded inside the R script.
#!! seed [optional]
# @@seed@@ sets random seeds for programs involving random number generators. Setting a range of seeds naturally creates "replicates" of the same scenario or same methods; evaluation over these replicates will have to be averaged in the ""score"" sequence.
# If the random seeds correspond to R scripts in @@exe@@, the R function @@set.seed()@@ will be used to set seed for the R scripts; otherwise the seed values have to be passed to @@exe@@ the same fashion as other parameters, for example @@ms ... -seed $seed@@ as demonstrated above.
#!! params [optional]
# Typical entries of @@params@@ reads:
#{out yaml
params:
  n: 1000
  mean: 0, 1
#}
# which indicates that there are 2 input parameters, namely @@n@@ and @@mean@@, to all commands in @@exe@@.
# Often, there are parameters unique to one @@exe@@ but not others. Executable specific parameter syntax is needed in this case:
#{out yaml
params:
  n: 1000
  mean: 0, 1
  exe[1]:
    t: 10
#}
# where @@n@@ and @@mean@@ are shared by all @@exe@@ but parameter @@t@@ is only used by the first executable in @@exe@@.
#!! return [required]
# @@return@@ parameter are values to be saved at the end of computation for each block. Only @@return@@ values of one block can be referred to by other blocks. For example:
#{out yaml
simulate:
    ...
    return: x, y, z
#}
# then @@return@@ values @@x@@, @@y@@ and @@z@@ can be used in other blocks, for example,
#{out yaml
test:
    params:
      data: {.}$x, {.}$y, {.}$z
#}
# where the input parameter @@data@@ for ``test'' consists of values from @@return@@ of ``simulate''.
#! Auxiliary parameters
# Auxiliary parameters define rules under which parameters are combined or renamed in a DSC pipeline.
#!! __logic__
# @@__logic__@@ defines how parameter values are combined. It overrides the default logic that all parameters are combined through Cartesian product. For example:
#{out yaml
params:
  n: 100, 200, 300, 400, 500
  mu: 0, 1
  exe[1]:
    sigma: 1, 2
    __logic__: Product(n[1:3], mu[1], sigma), Product(n[4,5], mu[2], sigma[1])
#}
# Without the @@__logic__@@ keyword, DSC will run all combinations of 5 values of @@n@@, 2 of @@mu@@ and 2 of @@sigma@@, a total of 20 parallel jobs. The @@__logic__@@ here states that instead of 20 jobs, DSC will first run 3 values of @@n@@ with @@mu = 0@@ and 2 values of @@sigma@@, then run another 2 values of @@n@@ with @@mu = 1@@ and @@sigma = 1@@, which is a total of 8 jobs. Notice that parameter index slicing makes it possible to run a subset of parameter values.
#!! __alias__
# @@__alias__@@ is an argument name parser. For example:
#{out yaml
params:
  mu: 1, 2, 3
  exe[2]:
    __alias__: theta = mu
#}
# then all @@exe@@ takes a parameter @@mu@@, except for @@exe[2]@@ which takes parameter @@theta@@ instead, but @@theta@@ in @@exe[2]@@ is equivalent to @@mu@@ in other @@exe@@. To reflect the logic, DSC loads values from @@mu@@ and assign them to @@theta@@ when it comes to @@exe[2]@@.
# FIXME: explain the scope of @@__alias__@@

###
# DSC block operators
###
#! Primary operators
#!! R(), Python(), Shell()
# These operators run codes inside parenthesis using R, Python or Shell and evaluates the output. For example @@seed: R(1:5)@@ results in @@seed: 1, 2, 3, 4, 5@@.
#!! Asis()
# This is useful in setting parameters for R scripts: contents inside @@Asis()@@ operator will be passed to variables in R "as is", not in string form. For example
#{out yaml
g: Asis(normalmix(c(2/3,1/3),c(0,0),c(1,2)))
#}
# will result in
#{r
g = normalmix(c(2/3,1/3),c(0,0),c(1,2))
#}
# But without @@Asis()@@ it will read
#{r
g = "normalmix(c(2/3,1/3),c(0,0),c(1,2))"
#}
#!! ()
# A bare parenthesis groups parameters as one unit. For example @@(1,2,3)@@ will be translated to vector assignment ``c(1, 2, 3)'' in R script, or space separated argument sequence @@1 2 3@@ for other command line programs.
#! Auxiliary operators
#!! RList()
# This is used in @@__alias__@@ entries to help construct variables for R. For example @@__alias__: RList(args)@@ will convert variables in corresponding parameter space, say @@x,y,z@@ to @@args = list(x = ..., y = ..., z = ...)@@
#!! Product()
# Cartesian product of parameters used in @@__logic__@@ entries, see examples above.
#!! Pairwise()
# FIXME
#!! Index slicing
# For example, @@n[1,2,4]@@ extracts the first, second and forth elements of @@n@@. @@n[1:4]@@ extracts elements 1 though 4, and @@n[1:9:2]@@ extracts elements 1, 3, 5, 7, 9.
###
# DSC Sequences
###
# Blocks are called from the ""DSC"" section as "sequences". Their relationship is defined by ``+'', ``,'' and ``()'' operators:
#{list
# ``+'': right side is executed after the left side
# ``,'': right side and left side are concurrent
# ``()'': allows for combinations of ``+'' and ``,''
#}
# ""Example 1"":
#{out yaml
method: transform + estimate
#}
# DSC will run ``transform'' first, followed by ``estimate''.
# ""Example 2"":
#{out yaml
method: transform + estimate, estimate
#}
# DSC will run 2 concurrent sequences of steps. The first involves ``transform'' followed by ``estimate''; the second is ``estimate'' only.
# Slicing is supported, for example:
#{out yaml
method: transform[1:3] + estimate[1], transform[4:5] + estimate[2], estimate
#}
# ""Example 3"":
#{out yaml
method: (voom, sqrt, identity) + (RUV, SVA) + (DESeq, edgeRglm, ash)
#}
# FIXME
#! Runtime variables
#{list
# @@exe_path@@
# @@R_libs@@
# @@output@@
# @@variables@@
#}
