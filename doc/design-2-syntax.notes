###
#! DSC2 syntax
###
###
# DSC file structure
###
# DSC2 is configured by a text file in [YAML format|@http://yaml.org@] (referred to as "DSC file" hereafter) with multiple sections. Each section in the DSC file, except for the last one (section name ""DSC""), is called a "DSC block" (referred to as "block" hereafter). All blocks share the same syntax.
# The ""DSC"" section consists of a [""DSC sequence""|@Design-and-Features#Design-Overview@], plus a ""runtime"" environment which specifies various other parameters in a DSC run (for example required R libraries, path to executable folders, DSC global variables and output database names).
# Lines in a DSC file are called "DSC entries", separated by comma (``,''), to allow for a range of parameters be assigned to multiple computational routine so that DSC can be performed under various scenarios for many methods.
# You may glance over these DSC files to have an idea of DSC2 syntax. It is also recommended that you read the [DSC design|@Design-and-Features@] before diving into the details throughout the rest of the document.
#{list
# [Location parameter estimate I|@https://github.com/stephenslab/dsc2/tree/master/vignettes/one_sample_location/settings.yaml@] and [II|@https://github.com/stephenslab/dsc2/tree/master/vignettes/one_sample_location_qnorm/settings.yaml@]
# [Adaptive Shrinkage|@https://github.com/stephenslab/dsc2/tree/master/vignettes/ash/settings.yaml@]
# [Adaptive Shrinkage on variance|@https://github.com/stephenslab/dsc2/tree/master/vignettes/vash/settings.yaml@]
# [Outlier detection from population data I|@https://github.com/stephenslab/dsc2/tree/master/vignettes/outlier_r/settings.yaml@] and [II|@https://github.com/stephenslab/dsc2/tree/master/vignettes/outlier_snakemake/settings.yaml@]
#}
###
# DSC Block Parameters
###
# Block parameters are labels of DSC entries that constitute a DSC block.
#! exe [required]
# @@exe@@ specifies the names of executable computational routines as well as their command line arguments if applicable. For example a @@exe@@ entry reads:
#{out yaml
exe: datamaker.R, ms $nsam $nreps -t $theta -seed $seed
#}
# where data is generated by two programs, @@datamaker.R@@ and @@ms@@, with command line arguments @@nsam@@, @@nreps@@ and @@theta@@ & @@seed@@ for @@ms@@. Although @@exe@@ takes arbitrary command line programs, if the input is R script, for example @@datamaker.R@@, then there is no need to explicitly specify input parameters such as @@nsam@@ and @@nreps@@, as long as the parameter names match the variable names coded inside the R script. For the case of @@ms@@ here, input parameters should start with @@$@@ and followed by parameter names which will be found under [@@params@@|@DSC2-Syntax#params-optional@] entry of ""the same block"".
#! seed [optional]
# @@seed@@ sets random seeds for programs involving random number generators. Setting a range of seeds naturally creates "replicates" of the same scenario or same methods; evaluation over these replicates will have to be averaged in the ""score"" sequence.
# If the random seeds correspond to R scripts in @@exe@@, the R function @@set.seed()@@ will be used to set seed for the R scripts; otherwise the seed values have to be passed to @@exe@@ the same fashion as other parameters, for example @@ms ... -seed $seed@@ as demonstrated above.
#! params [optional]
# @@params@@ defines parameters to be passed into computational routines under @@exe@@. It is a indented list having an arbitrary length that matches requirement of @@exe@@ entries. A typical @@params@@ reads:
#{out yaml
params:
  n: 1000, 2000
  mean: 0, 1
#}
# which indicates that there are 2 input parameters, namely @@n@@ and @@mean@@, to all commands in @@exe@@. Values for each parameter is a vector and will be assigned to all executables through combinations in Cartesian product fashion unless [otherwise specified|@DSC2-Syntax#__logic__@]. For example, each executable under @@exe@@ will take 4 sets of parameter from the example above: @@(n = 1000, mean = 0), (n = 1000, mean = 1), (n = 2000, mean = 0), (n = 2000, mean = 1)@@.
#!! exe specific parameters
# Often, there are parameters unique to one @@exe@@. Executable specific parameter assignment is needed in this case:
#{out yaml
params:
  n: 1000, 2000
  mean: 0, 1
  exe[1]:
    t: 5, 10
#}
# where @@n@@ and @@mean@@ are shared by all @@exe@@ but parameter @@t@@ is only used by the first executable (indexed by @@[1]@@) in @@exe@@.
#!! Grouped parameters
# FIXME
#! return [required]
# @@return@@ parameter are values to be saved at the end of computation for each block. Only @@return@@ values of one block can be referred to by other blocks (via the [@@$@@ symbol|@DSC2-Syntax#and@]). For example:
#{out yaml
simulate:
    ...
    return: x, y
#}
# then @@return@@ values @@x@@, @@y@@ and @@z@@ can be used in other blocks, for example,
#{out yaml
test:
    params:
      x: $x
      y: $y
#}
# where input parameters @@x@@ and @@y@@ for ``test'' consists of values from @@return@@ of ``simulate''.
# It is possible to use @@__alias__@@-like syntax in return, for example to extract a specific attribute from an R list:
#{out yaml
return: data, beta = R(data$meta$beta)
#}
# then in addition to returning @@data@@ which is an R list, it also returns value @@beta@@ which is part of the @@data@@ list, i.e., @@data$meta$beta@@.
#! __logic__ [optional]
# @@__logic__@@ defines how parameter values are combined. It can be used under @@exe@@ entry or inside @@params@@ entry. Operators used in a @@__logic__@@ entry is the same as those used in [DSC sequences|@DSC2-Syntax#dsc-sequences@].
#!! For executables
# When @@__logic__@@ occurs under @@exe@@ entry, it defines how the computational routines should be combined. Without it these routines are independent from each other. But with @@__logic__@@, for example:
#{out yaml
  method:
      exe: test1.R, test2.R
      __logic__: exe[2], exe[1] + exe[2]
#}
# then the DSC pipeline will run two new procedures in parallel, one runs only @@test1.R@@, the other runs @@test1.R@@ followed by @@test2.R@@.
# A handy user case for @@__logic__@@ under @@exe@@ is pre/post processing of data for/from third-party software, for example:
#{out yaml
admixture:
    exe: make_ped.py $data $ped,
         admixture $ped $K > $output,
         new_admixture_method.R $data $output
    __logic__: exe[1] + exe[2], exe[3]
#}
# Here two different admixture analysis methods are compared, the @@admixture@@ program and a new method under development, coded in @@mew_admixture_method.R@@. The @@admixture@@ program requires input data in PED format, and a @@make_ped.py@@ script is used to convert data to PED. @@__logic__@@ here indicates that @@exe[1]@@ is a pre-processor for @@exe[2]@@ and they should always be combined as one unit.
#!! For parameters
# When @@__logic__@@ occurs inside params entry, it overrides the default logic that all parameters are combined through Cartesian product. For example:
#{out yaml
params:
  n: 100, 200, 300, 400, 500
  mu: 0, 1
  exe[1]:
    sigma: 1, 2
    __logic__: n[1:3] * mu[1] * sigma, n[4,5] * mu[2] * sigma[1]
#}
# Without the @@__logic__@@ keyword, DSC will run all combinations of 5 values of @@n@@, 2 of @@mu@@ and 2 of @@sigma@@, a total of 20 parallel jobs. The @@__logic__@@ here states that instead of 20 jobs, DSC will first run 3 values of @@n@@ with @@mu = 0@@ and 2 values of @@sigma@@, then run another 2 values of @@n@@ with @@mu = 1@@ and @@sigma = 1@@, which is a total of 8 jobs. Notice that parameter index slicing makes it possible to run a subset of parameter values.
#! __alias__ [optional]
# @@__alias__@@ is often used to adjust parameter names for input to different executables. For example:
#{out yaml
params:
  mu: 1, 2, 3
  exe[2]:
    __alias__: theta = mu
#}
# then all @@exe@@ takes a parameter @@mu@@, except for @@exe[2]@@ which requires parameter with name @@theta@@, but @@theta@@ in @@exe[2]@@ is equivalent to @@mu@@ in other @@exe@@. To reflect the logic, DSC loads values from @@mu@@ and assign them to @@theta@@ for @@exe[2]@@.
#!! Scope of __alias__
# When @@__alias__@@ is used under @@params@@ but outside any @@exe[i]@@, then it will also effect all parameters under @@exe[i]@@ when applicable. However this behavior can be overloaded by @@__alias__@@ under @@exe[i]@@.
###
# DSC block operators
###
#! R(), Python(), Shell()
# These operators run codes inside parenthesis using R, Python or Shell interpreters and evaluate the output. For example @@seed: R(1:5)@@ results in @@seed: 1, 2, 3, 4, 5@@.
#! $, $$ and $()
#!! $ in @@exe@@ entry
# In @@exe@@, @@$@@ refers to parameters under @@params@@ within the same block.
#!! $ in @@params@@ entry
# In @@params@@ entry, @@$@@ refers to return values from another block.
#! $$
# This symbol is used to refer to return variables from another block when used with @@R(), Python() and Shell()@@ operators. For example @@data: $x@@ assigns return value @@x@@ from another block to parameter @@data@@, but when @@x@@ is used with operators above-mentioned, the syntax becomes @@data: R(some_r_function($$x))@@ where @@some_r_function@@ takes value of @@x@@ as input and return an output to be assigned to @@data@@. @@$$x@@ is used instead of @@$x@@ to avoid conflicting with @@$@@ operator in R. Same holds for @@Shell()@@ and although @@$@@ is not a Python operator, the same convention is used for @@Python()@@ for consistency.
#!! $()
# @@$()@@ refers to variables defined in @@DSC::runtime::variables@@ section. For example:
#{out yaml
simulate:
    exe: Product(datamaker.R, $(data_functions))
...
DSC:
    ...
    runtime:
        variables:
            data_functions: mvngenotypes, discrete.cosine, discrete.cosine2, discrete.cosine.peaksel
#}
# is equivalent to
#{out yaml
simulate:
    exe: datamaker.R mvngenotypes, datamaker.R discrete.cosine,
         datamaker.R discrete.cosine2, datamaker.R discrete.cosine.peaksel
#}
#! (), the group operator
# A bare parenthesis groups parameters as one unit. For example:
#{out yaml
exe: method.R, program.exe $K
params:
   K: (1,2,3), (4,5,6)
#}
# With @@()@@, @@(1,2,3)@@ will be translated to vector assignment ``c(1, 2, 3)'' in the R script, or space separated argument sequence @@program.exe 1 2 3@@ for the other command line program. Values will be assigned in units of 3 instead of separately.
#! Combo(), Pairs()
# Cartesian combinations and paired grouping of parameters. This can be considered short-cut for assigning values in DSC entries. For example:
#{out yaml
exe: Combo(classifier.R (kernal_1, kernal_2, kernal_3))
#}
# is equivalent to
#{out yaml
exe: classifier.R kernal_1, classifier.R kernal_2, classifier.R kernal_3
#}
#! Asis()
# In DSC file, numeric vs. string data-types are automatically determined and there is no need to add quotes to strings. This is convenient in most cases but can be problematic when the input appear as strings but are in fact, for example, actual R codes that should not be converted to strings. @@Asis()@@ operator will be useful for this case. For example,
#{out yaml
g: Asis(normalmix(c(2/3,1/3),c(0,0),c(1,2)))
#}
# will result in
#{r
g = normalmix(c(2/3,1/3),c(0,0),c(1,2))
#}
# But without @@Asis()@@ it will read
#{r
g = "normalmix(c(2/3,1/3),c(0,0),c(1,2))"
#}
#! File(), TempFile()
# When a DSC string parameter is a file name, it is required that @@File()@@ operator be applied to the parameter to indicate that it stands for a file. This serves two purposes. First, being aware of existence of relevant files, DSC will keep track of MD5 hash of these files in order to monitor if they are modified. Secondly, the operator allows for a flexible file name specification theme. For example:
#{out yaml
    params:
        data: File($sim)
        K: 1, 2, 3, 4, 5
        score: File(prefix = admixture_test, suffix = score)
    return: score
#}
# Here the input parameter @@data@@ is a file with name @@$sim@@ (which, due to @@$@@ symbol, is apparently return value from another block). The return value @@score@@ is also a file, likely generated by the computational routine taking input @@data@@ file and 5 values of parameter @@K@@. As a result, the returned @@score@@ should be 5 files. With @@prefix/suffix@@ syntax inside @@File()@@ operator, the names of these 5 output @@score@@ files will be automatically assigned, under the pattern of @@admixture_test_*.score@@. Users therefore do not have to worry about file name specifications due to different combinations of parameters.
# @@TempFile()@@ is the same as @@File()@@ operator except for one property: hash for @@TempFile()@@ will not be tracked and it will be removed at the end of a computational step.
#! FromFile()
# This is used in @@__alias__@@ entries as a shortcut to indicate multiple string variables being file names, for example:
#{out yaml
  params:
    data: 1.txt, 2.txt, 3.txt, 4.txt, 5.txt
    __alias__: FromFile(data)
#}
# is equivalent to
#{out yaml
  params:
    data: File(1.txt), File(2.txt), File(3.txt), File(4.txt), File(5.txt)
#}
#! Prefix(), Suffix()
# These are used to extract patterns from file names, for example:
#{out yaml
    params:
        data: File($sim)
        ped: File(Prefix($sim).ped)
        ...
#}
# where @@ped@@ shares the same file prefix as @@data@@ but differ in extension. @@Suffix@@, on the other hand, is used to extract file extensions.
#! RList()
# This is used in @@__alias__@@ entries to help construct variables for R. For example @@__alias__: args = RList()@@ will convert all variables in corresponding parameter space, say @@x,y,z@@ to @@args = list(x = ..., y = ..., z = ...)@@. @@args = RList(x, y)@@ will only convert selected variables to R list, @@args = list(x = x, y = y)@@.
#! Index and slicing
# Index can be used in the following context:
#{list
# Index parameters for @@exe@@ entry, for example @@exe: makeped.py $data $output[1]@@ where @@output@@ parameter takes the form of @@output: (1.ped, 1.map), (2.ped, 2.map)@@.
# Index for variables in @@__logic__@@ entries.
# Index for variables in @@DSC::run@@ sequence.
#}
# Slicing syntax is allowed. For example, @@n[1,2,4]@@ extracts the first, second and forth elements of @@n@@. @@n[1:4]@@ extracts elements 1 though 4, and @@n[1:9:2]@@ extracts elements 1, 3, 5, 7, 9.
###
# Block inheritance
###
# When multiple blocks share similar specifications, block inheritance is introduced to make this specifications more succinct. For example:
#{out yaml
SVA:
    exe: SVA.R
    params:
        data: $data
        __alias__: RList(args)
    return: data

RUV(SVA):
    exe: RUV.R

voom(SVA):
    exe: voom.R
#}
# Here, the 3 blocks differ only in the executable name. Block inheritance allows defining @@SVA@@ completely, then inherit it to define ``RUV'' and ``voom'' where only @@exe@@ have to be re-defined.
###
# DSC Sequences
###
# Blocks are executed from the ""DSC"" section as "sequences". Ways these blocks are combined can be specified via ``*'', ``,'' and ``()'' operators:
#{list
# ``*'': right side is executed after the left side
# ``,'': right side and left side are concurrent
# ``()'': allows for combinations of ``*'' and ``,''
#}
# These operators also applies to @@__logic__@@ entries which defines the ways executables or parameters are combined.
#! Example 1
#{out yaml
run: simulate * (transform * estimate) * score
#}
# DSC will run ``transform'' first, followed by ``estimate''.
#! Example 2
#{out yaml
run: simulate * (transform * estimate, estimate) * score
#}
# DSC will run 2 concurrent sequences of steps. The first involves ``transform'' followed by ``estimate''; the second is ``estimate'' only.
# Slicing is supported, for example:
#{out yaml
run: simulate * (transform[1:3] * estimate[1], transform[4:5] * estimate[2], estimate) * score
#}
#! Example 3
#{out yaml
run: simulate * (voom, sqrt, identity) * (RUV, SVA) * (DESeq, edgeRglm, ash) * score
#}
# will be expanded to:
#{out yaml
run: simulate * sqrt * RUV * DESeq * score,
     simulate * sqrt * SVA * DESeq * score,
     simulate * identity * RUV * DESeq * score,
     simulate * voom * RUV * DESeq * score,
     simulate * identity * SVA * DESeq * score,
     simulate * voom * SVA * DESeq * score,
     simulate * sqrt * RUV * ash * score,
     simulate * sqrt * RUV * edgeRglm * score,
     simulate * sqrt * SVA * ash * score,
     simulate * sqrt * SVA * edgeRglm * score,
     simulate * identity * RUV * ash * score,
     simulate * voom * RUV * ash * score,
     simulate * identity * RUV * edgeRglm * score,
     simulate * voom * RUV * edgeRglm * score,
     simulate * identity * SVA * ash * score,
     simulate * voom * SVA * ash * score,
     simulate * identity * SVA * edgeRglm * score,
     simulate * voom * SVA * edgeRglm * score
#}
###
# Runtime variables
###
#{list
# @@exe_path@@: search path for executable files
# @@R_libs@@: required R libraries, from cran, bioconductor or github. The following specifications are allowed
## @@name@@: DSC will first attempt to find it from cran, then bioconductor.
## @@cran/name/version@@: DSC will install given package with given version from cran.
## @@bioc/name@@: DSC will install the package from bioconductor.
## @@github/repo/name@@: DSC will install given package from given repository on github.
# @@output@@: File prefix for output DSC database.
# @@variables@@: Defines DSC variables which can be used anywhere in the DSC file through @@$()@@ syntax.
#}
