###
#! DSC2 syntax
###
###
# DSC Terminology
###
#{list
# ""DSC file"": a text file in [YAML format|@http://yaml.org@] that configures the entire DSC procedure.
# ""DSC block"": Sections in DSC file that defines a family of computational routines.
# ""Block parameters"": Labels of DSC entries within DSC blocks.
## Available block parameters: @@exec@@, @@params@@, @@seed@@, @@return@@, @@.alias@@, @@.logic@@, @@.options@@
# ""DSC entry"": Lines in DSC blocks, labeled by block parameters and separated by comma (``,''), to allow for a range of parameters be assigned to multiple computational routine so that DSC can be performed under various scenarios for many methods.
# ""DSC block operators"": Operators that can be called in DSC entries to generate desired result from its input.
# ""The DSC Section"": A special section consisting of a [""DSC sequence""|@Design-and-Features#Design-Overview@], plus various other parameters involved in a DSC procedure (including required R libraries, path to executable folders, DSC global variables and work directory).
# ""DSC sequence"" & ""DSC sequence operators"": A sequence of logical expression that defines how the DSC blocks should be connected with each other.
# ""DSC variables"": The @@parameters@@ entry in the DSC section that defines variables to be accessed by DSC blocks (via @@$()@@ sigil).
#}
# You may glance over these DSC files to have an idea of DSC2 syntax. It is also recommended that you read the [DSC design|@Design-and-Features@] before diving into the details throughout the rest of the document.
#{list
# [Location parameter estimate I|@https://github.com/stephenslab/dsc2/tree/master/vignettes/one_sample_location/settings.yaml@] and [II|@https://github.com/stephenslab/dsc2/tree/master/vignettes/one_sample_location_qnorm/settings.yaml@]
# [Adaptive Shrinkage|@https://github.com/stephenslab/dsc2/tree/master/vignettes/ash/settings.yaml@]
# [Adaptive Shrinkage on variance|@https://github.com/stephenslab/dsc2/tree/master/vignettes/vash/settings.yaml@]
# [Outlier detection from population data I|@https://github.com/stephenslab/dsc2/tree/master/vignettes/outlier_r/settings.yaml@] and [II|@https://github.com/stephenslab/dsc2/tree/master/vignettes/outlier_snakemake/settings.yaml@]
#}
###
# DSC Block Parameters
###
# A DSC block is composed by block parameters. Block parameters are labels of DSC entries.
#! exec [required]
# @@exec@@ specifies the names of executable computational routines as well as their command line arguments if applicable. For example a @@exec@@ entry reads:
#{out yaml
exec: datamaker.R, ms $nsam $nreps -t $theta -seed $seed
#}
# where data is generated by two programs, @@datamaker.R@@ and @@ms@@, with command line arguments @@nsam@@, @@nreps@@ and @@theta@@ & @@seed@@ for @@ms@@. Although @@exec@@ takes arbitrary command line programs, if the input is R script, for example @@datamaker.R@@, then there is no need to explicitly specify input parameters such as @@nsam@@ and @@nreps@@, as long as the parameter names match the variable names coded inside the R script. For the case of @@ms@@ here, input parameters should start with @@$@@ and followed by parameter names which will be found under [@@params@@|@DSC2-Syntax#params-optional@] entry of ""the same block"".
#! params [optional]
# @@params@@ defines parameters to be used by computational routines under @@exec@@. It is a indented list with labels (parameter names) matching arguments of @@exec@@ entries, or variable names in R if the @@exec@@ routine in question is R script. A typical @@params@@ reads:
#{out yaml
params:
  n: 1000, 2000
  mean: 0, 1
#}
# which indicates that there are 2 input parameters, namely @@n@@ and @@mean@@, for computational routines defined in @@exec@@. Combinations of parameter values (Cartesian product style) will be assigned to all @@exec@@ unless [otherwise instructed|@DSC2-Syntax#.logic@]. For example, each executable under @@exec@@ will take 4 sets of parameter from the example above: @@(n = 1000, mean = 0), (n = 1000, mean = 1), (n = 2000, mean = 0), (n = 2000, mean = 1)@@.
#!! Exec specific parameters
# Often, there are parameters unique to one @@exec@@. Executable specific parameter assignment is needed in this case:
#{out yaml
params:
  n: 1000, 2000
  mean: 0, 1
  exec[1]:
    t: 5, 10
#}
# where @@n@@ and @@mean@@ are shared by all @@exec@@ but parameter @@t@@ is only used by the first executable (indexed by @@[1]@@) in @@exec@@.
#!! Grouped parameters
# This feature organize parameters in groups to enhance readability. However these group names are annotation only and will be ignored by DSC interpreter. For example the following two blocks are equivalent:
#{out yaml
params:
  sample_params:
    n_samples: 1000, 2000
    p_cases: 0.5
  genotype_params:
    n_snps: 500, 800
    n_genes: 20
#}
#{out yaml
params:
  n_samples: 1000, 2000
  p_cases: 0.5
  n_snps: 500, 800
  n_genes: 20
#}
#! seed [optional]
# @@seed@@ sets random seeds for programs involving random number generators. Setting a range of seeds naturally creates "replicates" of the same scenario or same methods; evaluation over these replicates may have to be averaged after DSC runs and the @@seed@@ parameter makes it possible to distinguish replicates from combinations of other parameters.
# If there are R scripts in @@exec@@, the R function @@set.seed()@@ will be called by DSC to set seed for the R scripts; otherwise the seed values will be be passed to @@exec@@ the same fashion as other parameters in @@params@@, for example @@ms ... -seed $seed@@ as demonstrated above.
#! return [required]
# @@return@@ parameter are values to be saved to disk at the end of computation for each block. Only @@return@@ values of a block can be referred to by other blocks (via the @@$@@ symbol). For example:
#{out yaml
simulate:
    ...
    return: x, y
#}
# then @@return@@ values @@x@@, @@y@@ and @@z@@ can be used in other blocks, for example,
#{out yaml
test:
    params:
      x: $x
      y: $y
#}
# where input parameters @@x@@ and @@y@@ for ``test'' consists of values from @@return@@ of ``simulate''.
# It is possible to use @@.alias@@-like syntax in return, for example to extract a specific attribute from an R list:
#{out yaml
return: data, beta = R(data$meta$beta)
#}
# then in addition to returning @@data@@ which is an R list, it also returns value @@beta@@ which is part of the @@data@@ list, i.e., @@data$meta$beta@@.
# For an R script, return value should correspond to a variable name in the R script and thus may or may not be in @@params@@. For other executables, return value should be one of the @@params@@ values. If return value is a file name, the corresponding file will be registered to DSC cache.
#! .logic [optional]
# @@.logic@@ defines how parameter values are combined. It can be used outside or inside @@params@@.
#!! For executables
# When @@.logic@@ occurs outside @@params@@, it uses the `+` operator to specify how the computational routines should be combined. These routines are independent from each other by default, but can be connected via @@.logic@@ entry, for example:
#{out yaml
  method:
      exec: test1.R, test2.R
      .logic: exec[2], exec[1] + exec[2]
#}
# then the DSC pipeline will run two new procedures in parallel, one runs only @@test2.R@@, the other runs @@test1.R@@ followed by @@test2.R@@.
# A handy user case for @@.logic@@ under @@exec@@ is pre/post processing of data for/from third-party software, for example:
#{out yaml
admixture:
    exec: make_ped.py $data $ped,
          admixture $ped $K > $output,
          new_admixture_method.R $data $output
    .logic: exec[1] + exec[2], exec[3]
#}
# Here two different admixture analysis methods are compared: the @@admixture@@ program and a new method under development, coded in @@new_admixture_method.R@@. The @@admixture@@ program requires input data in PED format, and a @@make_ped.py@@ script is used to convert data to PED. @@.logic@@ here indicates that @@exec[1]@@ is a pre-processor for @@exec[2]@@ and they should always be combined as one unit.
#!! For parameters
# When @@.logic@@ occurs inside @@params@@, it overrides the default logic (that all parameters are combined the Cartesian product style). [DSC sequence|@DSC2-Syntax#dsc-sequences@] operators are supported. For example:
#{out yaml
params:
  n: 100, 200, 300, 400, 500
  mu: 0, 1
  exec[1]:
    sigma: 1, 2
    .logic: n[1:3] * mu[1] * sigma, n[4,5] * mu[2] * sigma[1]
#}
# Without the @@.logic@@ keyword, DSC will run all combinations of 5 values of @@n@@, 2 of @@mu@@ and 2 of @@sigma@@, a total of 20 parallel jobs. The @@.logic@@ here states that instead of 20 jobs, DSC will first run 3 values of @@n@@ with @@mu = 0@@ and 2 values of @@sigma@@, then run another 2 values of @@n@@ with @@mu = 1@@ and @@sigma = 1@@, which is a total of 8 jobs. Notice that parameter index slicing makes it possible to run a subset of parameter values.
#! .alias [optional]
# @@.alias@@ is often used to adjust parameter names for input to different executables. For example:
#{out yaml
params:
  mu: 1, 2, 3
  exec[2]:
    .alias: theta = mu
#}
# then all @@exec@@ takes a parameter @@mu@@, except for @@exec[2]@@ which requires parameter with name @@theta@@, but @@theta@@ in @@exec[2]@@ is equivalent to @@mu@@ in other @@exec@@. Under the hood DSC will load values from @@mu@@ and assign them to @@theta@@ for use with @@exec[2]@@.
#! .options [optional]
# @@.options@@ include parameters that controls behavior of the corresponding @@exec@@ as it executes, for example:
#{out yaml
# .options: ncpu = 2, mem = 4G
#}
# Supported options are:
#{list
# @@ncpu@@: Number of required CPUs.
# @@mem@@: Required memory.
# @@inline@@: True or False, of whether or not an R script is executed inline with the next procedure instead of producing return files. This feature is useful when the cost of computation for a procedure is trivial compared to the cost of storing its output. For example if a simulation procedure is simply @@runif(500000)@@ it makes more sense to save this line of code and execute it inline with the next step, rather than to save a vector of 500,000 random numbers to disk.
#}
# FIXME: example of inline R script
#!! Scope of .logic, .alias and .options
# When these parameters appear in @@params@@ but outside any @@exec[i]@@, then it will also effect all parameters under @@exec[i]@@ when applicable. However this behavior can be overloaded inside @@exec[i]@@ if the same parameter is re-defined.
# FIXME: example of scope
###
# DSC block operators
###
#! Sigils $ and $()
#!! $ in @@exec@@ entry
# In @@exec@@, @@$@@ refers to parameters defined inside @@params@@ of the same block.
#!! $ in @@params@@ entries
# In @@params@@, @@$@@ refers to return values from another block.
#!! $()
# @@$()@@ refers to variables defined in @@DSC::parameters@@. For example:
#{out yaml
simulate:
    exec: Combo(datamaker.R, $(data_functions))
...
DSC:
    ...
    parameters:
        data_functions: mvngenotypes, discrete.cosine, discrete.cosine2, discrete.cosine.peaksel
#}
# is equivalent to
#{out yaml
simulate:
    exec: datamaker.R mvngenotypes, datamaker.R discrete.cosine,
         datamaker.R discrete.cosine2, datamaker.R discrete.cosine.peaksel
#}
#! (), the group operator
# A bare parenthesis groups parameters as one unit. For example:
#{out yaml
exec: method.R, program.exe $K
params:
   K: (1,2,3), (4,5,6)
#}
# With @@()@@, @@(1,2,3)@@ will be translated to vector assignment ``c(1, 2, 3)'' in the R script, or space separated argument sequence @@program.exe 1 2 3@@ for the other command line program. Values will be assigned in units of 3 instead of separately.
#! R(), Python(), Shell()
# These operators run codes inside parenthesis using R, Python or Shell interpreters and evaluate the output. For example @@seed: R(1:5)@@ results in @@seed: 1, 2, 3, 4, 5@@.
#! Combo(), Pairs()
# Cartesian product and paired grouping of parameters. This can be considered short-cut for assigning values in DSC entries. For example:
#{out yaml
exec: Combo(classifier.R (kernal_1, kernal_2, kernal_3))
#}
# is equivalent to
#{out yaml
exec: classifier.R kernal_1, classifier.R kernal_2, classifier.R kernal_3
#}
#! Asis()
# In DSC file, numeric vs. string data-types are automatically determined and there is no need to add quotes to strings. This is convenient in most cases but can be problematic when the input appear as strings but are in fact, for example, actual R codes that should not be converted to strings. @@Asis()@@ operator will be useful for this case. For example,
#{out yaml
g: Asis(normalmix(c(2/3,1/3),c(0,0),c(1,2)))
#}
# will result in
#{r
g = normalmix(c(2/3,1/3),c(0,0),c(1,2))
#}
# But without @@Asis()@@ it will read
#{r
g = "normalmix(c(2/3,1/3),c(0,0),c(1,2))"
#}
# @@Asis()@@ can also be used to indicate a "raw string", for example:
#{out yaml
g: (1, 2, 3)
k: ('1', '2', '3')
l: (Asis('1', '2', '3'))
#}
# will result in
#{r
g = c(1, 2, 3)
k = c('1', '2', '3')
l = c("'1'", "'2'", "'3'")
#}
#! File()
# When a DSC string parameter is a file name but the file is yet to be created (by the current computational step), it is required that @@File()@@ operator be applied to the parameter to indicate that it represents a file / files although they do not yet exist . @@File()@@ operator allows for a flexible file name specification theme. For example:
#{out yaml
    params:
        data: $sim
        K: 1, 2, 3, 4, 5
        ped: File(prefix = admixture_data, suffix = (ped, map))
        score: File(prefix = admixture_test, suffix = score)
    return: score
#}
# Here the return value @@score@@ is a file, likely generated by the computational routine taking input @@data@@ file and 5 values of parameter @@K@@. As a result, the returned @@score@@ should be 5 files. With @@prefix/suffix@@ syntax inside @@File()@@ operator, the names of these 5 output @@score@@ files will be automatically assigned, for example @@admixture_test_1.score@@, @@admixture_test_2.score@@, @@admixture_test_3.score@@, @@admixture_test_4.score@@, @@admixture_test_5.score@@. Users therefore do not have to worry about file name specifications due to different combinations of parameters.
# When there are multiple suffix for example a pair of @@suffix = (ped, map)@@ for the @@ped@@ entry, then the resulting files are also in pairs: @@admixture_data_1.ped, admixture_data_1.map@@, ... @@admixture_data_5.ped, admixture_data_5.map@@.
# Only files in @@return@@ will be cached and saved. Other files are considered temporary files and will be removed upon completion of a computational step. In the example above, only @@score@@ file will be saved. The @@ped@@ files will be removed.
#! Prefix(), Suffix()
# These are used to extract patterns from file names, for example:
#{out yaml
    params:
        data: $sim
        ped: File(Prefix($sim).ped)
        ...
#}
# where @@ped@@ shares the same file prefix as @@data@@ (a file, which, due to @@$@@ symbol, is apparently return value from another block) but differ in extension. Likewise, @@Suffix@@ is used to extract file extensions.
#! RList()
# This is used in @@.alias@@ entries to help construct variables for R. For example @@.alias: args = RList()@@ will convert all variables in corresponding parameter space, say @@x,y,z@@ to @@args = list(x = ..., y = ..., z = ...)@@. @@args = RList(x, y)@@ will only convert selected variables to R list, @@args = list(x = x, y = y)@@.
#! Index and slicing
# Index can be used in the following context:
#{list
# Index for parameters in @@exec@@ entry, for example @@exec: makeped.py $data $output[1]@@ where @@output@@ parameter takes the form of @@output: (1.ped, 1.map), (2.ped, 2.map)@@.
# Index for @@exec@@ in @@.logic@@ inside and outside @@params@@; each element corresponds to a computational routine in @@exec@@
# Index for parameters defined by @@params@@ in @@.logic@@ inside @@params@@; each element corresponds to a value for the parameter.
# Index for block names in @@DSC::run@@ sequence; each element corresponds to a computational routine in @@exec@@.
#}
# Slicing syntax is allowed. For example, @@n[1,2,4]@@ extracts the first, second and forth elements of @@n@@. @@n[1:4]@@ extracts elements 1 though 4, and @@n[1:9:2]@@ extracts elements 1, 3, 5, 7, 9.
###
# Block inheritance
###
# When a new block shares similar specifications with existing blocks, block inheritance is introduced to make new block definition more succinct. For example:
#{out yaml
SVA:
    exec: SVA.R
    params:
        data: $data
        .alias: RList(args)
    return: data

RUV(SVA):
    exec: RUV.R

voom(SVA):
    exec: voom.R
#}
# Here, the 3 blocks differ only in the executable name. With block inheritance, we can completely configure @@SVA@@, then inherit it to configure ``RUV'' and ``voom'' where only @@exec@@ have to be re-defined.
###
# DSC Sequences
###
# Blocks are executed from the ""DSC"" section as "sequences", defined by the @@DSC::run@@ entry. Ways these blocks are connected can be specified via ``*'', ``,'' and ``()'' operators:
#{list
# ``*'': right hand side (RHS) is executed after the left hand side (LHS).
# ``+'': LHS and RHS are pair-wise combined first. ""In DSC, + operator has higher precedence than * operator"".
# ``,'': RHS and LHS are concurrent.
# ``()'': allows for combinations of ``*'' and ``,''.
#}
# These operators also apply to @@.logic@@ entries which define the ways parameters are combined.
#! Example 1
#{out yaml
run: simulate * (transform * estimate) * score
#}
# DSC will run ``transform'' first, followed by ``estimate''.
#! Example 2
#{out yaml
run: simulate * (transform * estimate, estimate) * score
#}
# DSC will run 2 concurrent sequences of steps. The first involves ``transform'' followed by ``estimate''; the second is ``estimate'' only.
# Slicing is supported, for example:
#{out yaml
run: simulate * (transform[1:3] * estimate[1], transform[4:5] * estimate[2], estimate) * score
#}
#! Example 3
#{out yaml
run: simulate * (voom, sqrt, identity) * (RUV, SVA) * (DESeq, edgeRglm, ash) * score
#}
# will be expanded to:
#{out yaml
run: simulate * sqrt * RUV * DESeq * score,
     simulate * sqrt * SVA * DESeq * score,
     simulate * identity * RUV * DESeq * score,
     simulate * voom * RUV * DESeq * score,
     simulate * identity * SVA * DESeq * score,
     simulate * voom * SVA * DESeq * score,
     simulate * sqrt * RUV * ash * score,
     simulate * sqrt * RUV * edgeRglm * score,
     simulate * sqrt * SVA * ash * score,
     simulate * sqrt * SVA * edgeRglm * score,
     simulate * identity * RUV * ash * score,
     simulate * voom * RUV * ash * score,
     simulate * identity * RUV * edgeRglm * score,
     simulate * voom * RUV * edgeRglm * score,
     simulate * identity * SVA * ash * score,
     simulate * voom * SVA * ash * score,
     simulate * identity * SVA * edgeRglm * score,
     simulate * voom * SVA * edgeRglm * score
#}
###
# DSC section parameters
###
#{list
# @@parameters@@: Defines DSC variables which can be used anywhere in the DSC file through @@$()@@ sigil.
# @@exec_path@@: search path for executable files.
# @@R_libs@@: required R libraries, from cran, bioconductor or github. The following specifications are allowed.
## @@name@@: DSC will first attempt to find it from cran, then bioconductor.
## @@cran/name/version@@: DSC will install given package with given version from cran.
## @@bioc/name@@: DSC will install the package from bioconductor.
## @@github/repo/name@@: DSC will install given package from given repository on github.
# @@work_dir@@: work directory where DSC runs take place.
#}
