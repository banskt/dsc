###
#! DSC2 syntax
###
###
# Overview
###
# DSC2 is configured by a text file in [YAML format|@http://yaml.org@] (referred to as "DSC file" hereafter). A DSC file typically consists of 4 sections: [3 DSC building blocks|@Features-of-DSC2#Overview@], plus a ""runtime"" section which specifies various other parameters in a DSC run (for example required R libraries, path to executable folders, DSC global variables and output database names).
# All except for the ""runtime"" section share the same structure and syntax.
# Lines in a DSC file are "DSC entries", separated by comma (``,''), to allow for a range of parameters be assigned to the same computational routine so that DSC can be performed under various scenarios for many methods.
# You may glance over these DSC files to have an idea of DSC2 syntax. More details can be found in the rest of this document.
#{list
# [Location parameter estimate|@https://github.com/stephenslab/dsc2/tree/master/vignettes/one_sample_location/settings.yaml@]
# [Location parameter comparison|@https://github.com/stephenslab/dsc2/tree/master/vignettes/two_sample_mean/settings.yaml@]
# [Adaptive Shrinkage|@https://github.com/stephenslab/dsc2/tree/master/vignettes/ash/settings.yaml@]
# [Adaptive Shrinkage on variance|@https://github.com/stephenslab/dsc2/tree/master/vignettes/vash/settings.yaml@]
# [Outlier detection from population data|@https://github.com/stephenslab/dsc2/tree/master/vignettes/outlier_r/settings.yaml@]
#}
###
# DSC parameters
###
#! Primary parameters
#!! exe [required]
# @@exe@@ specifies the name of executable computer routines as well as their parameters if applicable, for example a DSC entry reads:
#{out
exe: datamaker.R, ms $nsam $nreps -t $theta -seed $seed
#}
# where data is generated by two programs, @@datamaker.R@@ and @@ms@@, with command line parameters @@nsam@@, @@nreps@@ and @@theta@@ & @@seed@@ for @@ms@@ (parameters for @@exe@@ will be discussed in detail elsewhere). Although @@exe@@ takes arbitrary command-line programs, if the input is R script, for example @@datamaker.R@@ in this case, there is no need to explicitly specify input parameters such as @@nsam@@ and @@nreps@@, as long as the parameter names match the variable names in the R script.
#!! seed [optional]
# @@seed@@ sets random seeds for programs involving random number generators. Setting a range of seeds naturally creates "replicates" of the same scenario or same methods; evaluation over these replicates will have to be averaged in the ""score"" section.
# If the random seeds correspond to R scripts in @@exe@@, the R function @@set.seed()@@ will be used to set seed for the R scripts; otherwise the seed values have to be passed to @@exe@@ the same fashion as other parameters, for example @@ms ... -seed $seed@@ as demonstrated above.
#!! params [optional]
# Typical entries of @@params@@ reads:
#{out
params:
  n: 1000
  mean: 0, 1
#}
# which indicates that there are 2 input parameters, namely @@n@@ and @@mean@@, to all commands in @@exe@@.
# Often, there are parameters unique to one @@exe@@ but not others. Executable specific parameter syntax is needed in this case:
#{out
params:
  n: 1000
  mean: 0, 1
  exe[1]:
    t: 10
#}
# where @@n@@ and @@mean@@ are shared by all @@exe@@ but parameter @@t@@ is only used by the first executable in @@exe@@.
#!! return [required]
# @@return@@ parameter are values to be saved at the end of computation for each section. Only @@return@@ values of one section can be referred to by other sections. For example:
#{out
scenario:
    exe: ...
    params: ...
    return: x, y, z
#}
# then @@return@@ values @@x@@, @@y@@ and @@z@@ can be used in other sections, for example in ""method"" section,
#{out
method:
    params:
      data: $scenario$x, $scenario$y, $scenario$z
#}
# where the input parameter @@data@@ for ""method"" consists of values from @@return@@ of ""scenario"".
#! Auxiliary parameters
# Auxiliary parameters define rules under which parameters are combined or renamed in a DSC pipeline.
#!! __logic__
# @@__logic__@@ defines how parameter values are combined. It can occur under @@exe@@ entry or inside @@params@@ entry.
# When @@__logic__@@ occurs under @@exe@@ entry, for example:
#{out
method:
    exe: qnorm.R, ttest.R
    __logic__: exe[2], exe[1] + exe[2]
#}
# then the DSC pipeline will run two methods in parallel, one involves only @@ttest.R@@, the other runs @@qnorm.R@@ followed by @@ttest.R@@.
# Boolean operators are supported, for example:
#{out
exe: normal.R, t.R, uniform.R, mean.R, median.R, RMSE.R, MAE.R
__logic__: (exe[1] | exe[2] | exe[3]) + (exe[4] | exe[5]) + (exe[6] | exe[7])
#}
# When @@__logic__@@ occurs inside @@params@@ entry, it overrides the default logic that all parameters are combined through Cartesian product. For example:
#{out
params:
  n: 100, 200, 300, 400, 500
  mu: 0, 1
  exe[1]:
    sigma: 1, 2
    __logic__: Product(n[1:3], mu[1], sigma), Product(n[4,5], mu[2], sigma[1])
#}
# Without the @@__logic__@@ keyword, DSC will run all combinations of 5 values of @@n@@, 2 of @@mu@@ and 2 of @@sigma@@, a total of 20 parallel jobs. The @@__logic__@@ here states that instead of 20 jobs, DSC will first run 3 values of @@n@@ with @@mu = 0@@ and 2 values of @@sigma@@, then run another 2 values of @@n@@ with @@mu = 1@@ and @@sigma = 1@@, which is a total of 8 jobs. Notice that parameter index slicing makes it possible to run a subset of parameter values.
#!! __alias__
# @@__alias__@@ is an argument name parser. For example:
#{out
params:
  mu: 1, 2, 3
  exe[2]:
    __alias__: theta = mu
#}
# then all @@exe@@ takes a parameter @@mu@@, except for @@exe[2]@@ which takes parameter @@theta@@ instead, but @@theta@@ in @@exe[2]@@ is equivalent to @@mu@@ in other @@exe@@. To reflect the logic, DSC loads values from @@mu@@ and assign them to @@theta@@ when it comes to @@exe[2]@@.
# FIXME: explain the scope of @@__alias__@@
###
# DSC operators
###
#! Primary operators
#!! R(), Python(), Shell()
# These operators run codes inside parenthesis using R, Python or Shell and evaluates the output. For example @@seed: R(1:5)@@ results in @@seed: 1, 2, 3, 4, 5@@.
#!! Asis()
# This is useful in setting parameters for R scripts: contents inside @@Asis()@@ operator will be passed to variables in R "as is", not in string form. For example
g: Asis(normalmix(c(2/3,1/3),c(0,0),c(1,2)))
# will result in
g = normalmix(c(2/3,1/3),c(0,0),c(1,2))
# But without @@Asis()@@ it will read
g = "normalmix(c(2/3,1/3),c(0,0),c(1,2))"
#!! ()
# A bare parenthesis groups parameters as one unit. For example @@(1,2,3)@@ will be translated to vector assignment ``c(1, 2, 3)'' in R script, or space separated argument sequence @@1 2 3@@ for other command line programs.
#! Auxiliary operators
#!! RList()
# This is used in @@__alias__@@ entries to help construct variables for R. For example @@__alias__: RList(args)@@ will convert variables in corresponding parameter space, say @@x,y,z@@ to @@args = list(x = ..., y = ..., z = ...)@@
#!! Product()
# Cartesian product of parameters used in @@__logic__@@ entries, see examples above.
#!! Pairwise()
# FIXME
#!! Index slicing
# For example, @@n[1,2,4]@@ extracts the first, second and forth elements of @@n@@. @@n[1:4]@@ extracts elements 1 though 4, and @@n[1:9:2]@@ extracts elements 1, 3, 5, 7, 9.
###
# DSC variables
###
#! Section variables
#!! $scenario, $method
#! Runtime variables
#{list
# @@exe_path@@
# @@R_libs@@
# @@output@@
# @@variables@@
#}
