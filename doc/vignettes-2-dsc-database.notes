###
#! Exploring DSC output
###
# This is a continuation of [the Quick Start tutorial|@Quick-Start@]. Here we will focus on analyzing output from DSC.
# A DSC file has an entry @@DSC::output@@ where a output name must be specified. In our case it is
#{out yaml
DSC:
    ...
    output: dsc_result
#}
# This will produce 3 outcomes: a folder named @@dsc_result@@, a zipped [CSV file|@https://en.wikipedia.org/wiki/Comma-separated_values@] @@dsc_result.csv.gz@@ and a [SQLite3 database|@https://www.sqlite.org/@] @@dsc_result.db@@.
###
# DSC database
###
# File @@*.db@@ is DSC database in SQLite3 format. Users familiar with SQLite3 can interact with the database directly. Otherwise, DSC2 provides a simple command tool, @@dsc query@@, to explore the output.
# Columns of the DSC database consist of input parameters from all DSC blocks, plus ""return values which have simple data structure, i.e. integer, float or string"". Complex return values such as vectors or matrices will not show in the DSC database. Therefore, if the end result of your DSC is one or several numeric ``scores'', it is suggest that you explicitly ``return'' them at their corresponding DSC blocks as single numeric values so that they will be accessible from DSC database.
# To view the column names in DSC database:
dsc query dsc_result.db
#{out
INFO: Columns in DSC:
[text] __input__
[text] __output__
[integer] mean__mean_r
[real] mean__median_r
[real] mse__mse_r
[integer] n__rnorm_r
[integer] n__rt_r
[integer] seed__rnorm_r
[integer] seed__rt_r
[integer] true_mean__rnorm_r
[integer] true_mean__rt_r
#}
# Notice that the parameters from DSC file are renamed to @@<paramter name>__<exec name>@@, because different DSC blocks might have the same parameter names which can cause conflicts. Also there are two reserve column names @@__input__@@ and @@__output__@@ (will be discussed later).
# Now, suppose we want to find out the performance of location estimation via "median" method, under data generated from "t" distribution (df = 2). The relevant columns are @@true_mean__rt_r@@ (from @@simulation@@ block), @@mean__median_r@@ (from @@estimate@@ block) and @@mse__mse_r@@ (from @@mse@@ block). We can use the command below:
dsc query dsc_result.db -i true_mean__rt_r seed__rt_r mean__median_r mse__mse_r
#{out
true_mean__rt_r	seed__rt_r	mean__median_r	mse__mse_r
0	1	0.04460403758729076	0.0019895201690884466
0	2	0.10205332542770379	0.010414881230852813
0	3	-0.06355724379800415	0.004039523239198936
0	4	-0.03449161954973155	0.001189671819163424
0	5	-0.018833868071737606	0.0003547145865436172
0	6	-0.03560765449060073	0.0012679050583219982
0	7	-0.002000845373841088	4.0033822100212835e-06
0	8	-0.005369446959695264	2.8830960652980717e-05
0	9	-0.021656831005702114	0.0004690183292095404
0	10	-0.03996637917079164	0.001597311464023488
1	1	1.0446040375872907	0.001989520169088442
1	2	1.1020533254277036	0.010414881230852779
1	3	0.9364427562019959	0.0040395232391989295
1	4	0.9655083804502684	0.0011896718191634248
1	5	0.9811661319282624	0.0003547145865436167
1	6	0.9643923455093992	0.0012679050583220013
1	7	0.9979991546261588	4.003382210021545e-06
1	8	0.9946305530403048	2.883096065298016e-05
1	9	0.9783431689942979	0.0004690183292095419
1	10	0.9600336208292084	0.0015973114640234847
#}
# There are 10 rows for each @@true_mean@@ 0 or 1, due to the 10 seeds used. An additional column @@seed__rt_r@@ is added to the output to illustrate it. Often we are interested in averaged estimate over replicates. In this case we want to display the averaged location parameter estimate for @@true_mean@@ 0 or 1 as well as averaged error score, for example:
dsc query dsc_result.db -i 'avg(mean__median_r)' 'avg(mse__mse_r)' -g true_mean__rt_r
#{out
true_mean__rt_r	avg(mean__median_r)	avg(mse__mse_r)
0	-0.00748265254051096	0.0021355380239265268
1	0.9925173474594888	0.0021355380239265224
#}
# Here @@avg()@@ is a SQLite [aggregate function|@https://www.sqlite.org/lang_aggfunc.html@] and @@-g@@ means to group values by specified column before applying any functions. You can apply other aggregate functions to data.
# Displayed precision of output can be controlled by @@-p@@ option. For example to display up to 2 decimal points,
dsc query dsc_result.db -i 'avg(mean__median_r)' 'avg(mse__mse_r)' -g true_mean__rt_r -p 2
#{out
true_mean__rt_r	avg(mean__median_r)	avg(mse__mse_r)
0	-7.48E-03	2.14E-03
1	9.93E-01	2.14E-03
#}
###
# DSC database in text format
###
# File @@dsc_result.csv.gz@@ is a compressed text file containing the same information as @@dsc_result.db@@. This provides more flexibility to manipulate. For example to reproduce the results above with R:
#{r
> dat = read.table('dsc_result.csv.gz', sep = ',', header = T)
> colnames(dat)
 [1] "true_mean__rt.R"    "true_mean__rnorm.R" "seed__rt.R"
 [4] "seed__rnorm.R"      "n__rt.R"            "n__rnorm.R"
 [7] "mse__MSE.R"         "mean__median.R"     "mean__mean.R"
[10] "X__output__"        "X__input__"
> aggregate(cbind(mean__median.R, mse__MSE.R) ~ true_mean__rt.R, dat, mean)
  true_mean__rt.R mean__median.R  mse__MSE.R
1               0   -0.007482653 0.002135538
2               1    0.992517347 0.002135538
#}
# Note that naming convention of columns is slightly different.
###
# Intermediate output files
###
# The @@dsc_result@@ folder contains all output from DSC computational steps, specified by @@return@@ in each DSC block. These files are kept for two reasons:
#{list
# To serve as cache file so that a re-run can skip a step if their cached output matches cached runtime signature (in other words the cached output are up-to-date).
# To provide possibilities to access all intermediate output if desired.
#}
# For our example, there are 280 files in the folder:
#{out
003529110d65280c370d6a9627780b9f.rds
0083fdd52e04a0868fa68e4b5ccdfae1.rds
0196c1ba40557030f9965f56a44162ce.rds
02725265b27e7c6dce818dcf962d4e2e.rds
039c606d746dde1bf675cc18dd092097.rds
05a99e2c5ba0c31f17b77234ec024abc.rds
... ...
#}
# For an R based DSC as in this example, intermediate output are stored in [RDS format|@http://www.inside-r.org/r-doc/base/saverds@] and can be readily loaded in R, for example:
#{out r
> dat <- readRDS("dsc_result/c89f1d907020a06b5612c39cf5896524.rds")
> str(dat)
List of 2
 $ x        : num [1:1000] -1.7152 0.6057 0.0402 11.4315 -0.9899 ...
 $ true_mean: num 0
#}
# It shows two variables: @@x@@, which is a vector of length 1000, and @@true_mean@@ equals 0. Apparently this data-set is the outcome if a step from @@simulation@@ block.
# You can use the DSC database to figure out the input and output data for given computational step, and interact with them accordingly. For example, to find the output for simulation under "t" distribution with location parameter 0, you can use:
dsc query dsc_result.db -i true_mean__rt_r seed__rt_r __output__ -f "include(*__rt_r)" "true_mean__rt_r = 0"
#{out
true_mean__rt_r	seed__rt_r	__output__
0	1	263295362267da4be44a5afcceb4174f
0	2	b2b699414663552b43e49721739dbdca
0	3	c89f1d907020a06b5612c39cf5896524
0	4	78e35abad8bceef8050c9c69a4e82dd5
0	5	ae8683f2db25066a1fb7f36bd7a2302a
0	6	f36a974149b06737ca03d1c6f6538a47
0	7	72805cc3daab18ce0896a6dc097187b1
0	8	b5ecc2bd8771480c10f7e2318e1d2f4b
0	9	9b44bd1e9a4e3c12ca19b11ef26c7a46
0	10	3b399694fbc20a365e9a151f130f8cde
#}
# The output file name prefix identified here correspond to those RDS files in @@dsc_results@@ directory. We use a special function @@include()@@ because we want to focus on output generated by executable @@rt.R@@. We also provide a special function @@exclude()@@ which will exclude columns with the pattern specified. Only wildcard character @@*@@ is supported in these special functions.
