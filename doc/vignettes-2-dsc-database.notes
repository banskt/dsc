###
#! Exploring DSC output
###
# This is a continuation of [previous tutorial|@Quick-Start@]. Here we will focus on the output from DSC.
# A DSC file has an entry @@DSC::output@@ where a output name must be specified. In our case it is
#{out yaml
DSC:
    ...
    output: dsc_result
#}
# This will produce 3 outcomes: a folder named @@dsc_result@@, a zipped [CSV file|@https://en.wikipedia.org/wiki/Comma-separated_values@] @@dsc_result.csv.gz@@ and a [SQLite3 database|@https://www.sqlite.org/@] @@dsc_result.db@@.
###
# DSC database
###
# File @@*.db@@ is DSC database in SQLite3 format. Users familiar with SQLite3 can interact with the database directly. Otherwise, DSC2 provides a simple command tool, @@dsc query@@, to explore the output.
# Columns of the DSC database are all input parameters specified, plus ""return values with simple data structure of integer, float or string"". Complex return values such as vectors or matrices will not show in the DSC database. If the end result of your DSC is one or several numeric ``scores'' you should explicitly ``return'' them at their corresponding DSC blocks as single numeric values.
# To view the column names in DSC database:
dsc query dsc_result.db
#{out
INFO: Columns in DSC:
[text] __input__
[text] __output__
[integer] mean__mean_r
[real] mean__median_r
[real] mse__mse_r
[integer] n__rnorm_r
[integer] n__rt_r
[integer] seed__rnorm_r
[integer] seed__rt_r
[integer] true_mean__rnorm_r
[integer] true_mean__rt_r
#}
# Notice that the parameters from DSC file are renamed to @@<paramter name>__<exec name>@@, because different DSC blocks might have the same parameter names which can cause a conflict. Also there are two reserve column names @@__input__@@ and @@__output__@@ (will be discussed later).
# Now, suppose we want to find out the performance of estimating location parameter using the "median" method, under data generated from "t" distribution (df = 2). The relevant columns are @@true_mean__rt_r@@ (@@simulation@@ block), @@mean__median_r@@ (@@estimate@@ block) and @@mse__mse_r@@ (@@mse@@ block). We can use the command below:
dsc query dsc_result.db -i true_mean__rt_r mean__median_r mse__mse_r seed__rt_r
#{out
true_mean__rt_r	mean__median_r	mse__mse_r	seed__rt_r
0	0.04460403758729076	0.0019895201690884466	1
1	1.1020533254277036	0.010414881230852779	2
1	0.9946305530403048	2.883096065298016e-05	8
1	0.9364427562019959	0.0040395232391989295	3
1	1.0446040375872907	0.001989520169088442	1
0	-0.018833868071737606	0.0003547145865436172	5
0	-0.005369446959695264	2.8830960652980717e-05	8
1	0.9979991546261588	4.003382210021545e-06	7
0	0.10205332542770379	0.010414881230852813	2
1	0.9643923455093992	0.0012679050583220013	6
0	-0.06355724379800415	0.004039523239198936	3
0	-0.021656831005702114	0.0004690183292095404	9
0	-0.03560765449060073	0.0012679050583219982	6
0	-0.002000845373841088	4.0033822100212835e-06	7
1	0.9811661319282624	0.0003547145865436167	5
1	0.9783431689942979	0.0004690183292095419	9
0	-0.03449161954973155	0.001189671819163424	4
0	-0.03996637917079164	0.001597311464023488	10
1	0.9600336208292084	0.0015973114640234847	10
1	0.9655083804502684	0.0011896718191634248	4
#}
# There are 10 rows for each @@true_mean@@ 0 or 1, due to the 10 seeds used. An additional column @@seed__rt_r@@ is added to the output to illustrate it. Often we are interested in averaged estimate over replicates. In this case we want to display the averaged location parameter estimate for @@true_mean@@ 0 or 1 as well as averaged error score, for example:
dsc query dsc_result.db -i true_mean__rt_r 'avg(mean__median_r)' 'avg(mse__mse_r)' -g true_mean__rt_r
#{out
true_mean__rt_r	avg(mean__median_r)	avg(mse__mse_r)
0	-0.00748265254051096	0.0021355380239265268
1	0.9925173474594888	0.0021355380239265224
#}
# Here @@avg()@@ is a SQLite [aggregate function|@https://www.sqlite.org/lang_aggfunc.html@] and @@-g@@ means to group values by specified column before applying any functions. You can use other SQLite aggregate function to data.
# You can control the displayed precision of output using @@-p@@ option. For example to display up to 2 decimal points,
dsc query dsc_result.db -i true_mean__rt_r 'avg(mean__median_r)' 'avg(mse__mse_r)' -g true_mean__rt_r -p 2
#{out
true_mean__rt_r	avg(mean__median_r)	avg(mse__mse_r)
0	-7.48E-03	2.14E-03
1	9.93E-01	2.14E-03
#}
###
# DSC database in text format
###
# File @@dsc_result.csv.gz@@ contains the same information as @@dsc_result.db@@ in text format. This provides more flexibility to manipulate. For example with R:
#{r
> dat = read.table('dsc_result.csv.gz', sep = ',', header = T)
> colnames(dat)
 [1] "true_mean__rt.R"    "true_mean__rnorm.R" "seed__rt.R"
 [4] "seed__rnorm.R"      "n__rt.R"            "n__rnorm.R"
 [7] "mse__MSE.R"         "mean__median.R"     "mean__mean.R"
[10] "X__output__"        "X__input__"
> aggregate(cbind(mean__median.R, mse__MSE.R) ~ true_mean__rt.R, dat, mean)
  true_mean__rt.R mean__median.R  mse__MSE.R
1               0   -0.007482653 0.002135538
2               1    0.992517347 0.002135538
#}
# Note that naming convention of columns is slightly different.
###
# Intermediate output files
###
# The @@dsc_result@@ folder contains all output from DSC computational steps, specified by @@return@@ in each DSC block. For our example, there are 280 files in the folder:
#{out
003529110d65280c370d6a9627780b9f.rds
0083fdd52e04a0868fa68e4b5ccdfae1.rds
0196c1ba40557030f9965f56a44162ce.rds
02725265b27e7c6dce818dcf962d4e2e.rds
039c606d746dde1bf675cc18dd092097.rds
05a99e2c5ba0c31f17b77234ec024abc.rds
... ...
#}
# For an R based DSC as in this example, intermediate output are stored in [RDS format|@http://www.inside-r.org/r-doc/base/saverds@] and can be readily loaded in R, for example:
#{out r
> dat <- readRDS("dsc_result/c89f1d907020a06b5612c39cf5896524.rds")
> str(dat)
List of 2
 $ x        : num [1:1000] -1.7152 0.6057 0.0402 11.4315 -0.9899 ...
 $ true_mean: num 0
#}
# It shows two variables: @@x@@, which is a vector of length 1000, and @@true_mean@@ equals 0. Apparently this data-set is the outcome if a step from @@simulation@@ block.
# You can use the DSC database to figure out the input and output data for given computational step. For example, to find the output for simulation under "t" distribution with location parameter 0, you can use:
dsc query dsc_result.db -i true_mean__rt_r __output__ seed__rt_r -f "include(*__rt_r)" "true_mean__rt_r = 0"
#{out
true_mean__rt_r	__output__	seed__rt_r
0	9b44bd1e9a4e3c12ca19b11ef26c7a46	9
0	263295362267da4be44a5afcceb4174f	1
0	f36a974149b06737ca03d1c6f6538a47	6
0	b5ecc2bd8771480c10f7e2318e1d2f4b	8
0	b2b699414663552b43e49721739dbdca	2
0	78e35abad8bceef8050c9c69a4e82dd5	4
0	3b399694fbc20a365e9a151f130f8cde	10
0	c89f1d907020a06b5612c39cf5896524	3
0	ae8683f2db25066a1fb7f36bd7a2302a	5
0	72805cc3daab18ce0896a6dc097187b1	7
#}
# The output file name prefix identified here correspond to those RDS files in @@dsc_results@@ directory. We use a special function @@include()@@ because we want to focus on output generated by executable @@rt.R@@. We also provide a special function @@exclude()@@ which will exclude columns with the pattern specified. Only wildcard character @@*@@ is supported in these special functions.
